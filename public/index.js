/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Entry.ts":
/*!**********************!*\
  !*** ./src/Entry.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix */ \"./src/Matrix.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\nclass Entry {\r\n    constructor() {\r\n        this.initialize = () => __awaiter(this, void 0, void 0, function* () {\r\n            (yield _Matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].initialize()).show();\r\n        });\r\n        this.initialize();\r\n    }\r\n}\r\nnew Entry();\r\n\n\n//# sourceURL=webpack://html-static-myself/./src/Entry.ts?\n}");

/***/ }),

/***/ "./src/Matrix.ts":
/*!***********************!*\
  !*** ./src/Matrix.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nclass Matrix {\r\n    /*`За час своєї діяльності пан Віталій реалізував чимало важливих ініціатив, спрямованих на розвиток економіки міста,\\n` +\r\n                    `підтримку підприємництва та створення сприятливих умов для інвестицій.\\n` +\r\n                    `Компетентність, відданість справі та професійний підхід Віталія Люшина стали вагомим внеском у зміцнення та розвиток Рівненської громади.\\n` +\r\n                    `Тож бажаємо успіхів та нових професійних досягнень! - написали на сторінці міської ради. Нагадаємо, Віталія Люшина призначили'\\n'` +\r\n                    `на посаду керівника Департаменту економічного розвитку Віталія Люшина у серпні 2024 року.\\n` +\r\n                    `Довідково: Віталій Люшин народився 13 квітня 1977 року в селі Колодязне Березнівського району Рівненської області. Громадянин України.\\n` +\r\n                    `Освіта: вища, закінчив у 2001 році Рівненський державний технічний університет за спеціальністю „Землевпорядкування та кадастр”,\\n` +\r\n                    `здобувши кваліфікацію інженера-землевпорядника. У 2015 році здобув науковий ступінь кандидата економічних наук.\\n` +\r\n                    `З липня 2009 року по грудень 2015 року – директор Державного підприємства „Рівненський науково-дослідний та проектний' інститут землеустрою”.\\n` +\r\n                    `З лютого 2016 року по квітень 2016 року – фізична особа-підприємець.\\n` +\r\n                    `З липня 2016 року по березень 2017 року працював на посаді директора технічного ТзОВ „Березне-Землемір”.\\n` +\r\n                    `З 27 березня 2017 року розпорядженням Президента України був призначений головою Березнівської районної державної адміністрації Рівненської області.`;*/\r\n    constructor() {\r\n        this.text = [\r\n            {\r\n                part: \"WELCOME TO THE MATRIX\",\r\n                font: \"28px 'Courier New', monospace\",\r\n                color: \"#000000ff\",\r\n                align: \"center\"\r\n            },\r\n            {\r\n                part: \"System Initializing...\\nLoading protocols\",\r\n                font: \"18px monospace\",\r\n                color: \"#000000ff\",\r\n                align: \"center\"\r\n            },\r\n            {\r\n                part: \"User: Neo\\nAccess: Granted\",\r\n                font: \"16px monospace\",\r\n                color: \"#000000ff\",\r\n                align: \"center\"\r\n            }\r\n        ];\r\n        this.initialize = () => __awaiter(this, void 0, void 0, function* () {\r\n            this._page = document.getElementById(\"view-page\");\r\n            this._container = document.createElement(\"div\");\r\n            this._container.id = \"container\";\r\n            this._container.width = \"100%\";\r\n            this._container.style.setProperty('z-index', '9999');\r\n            this._container.style.setProperty(\"position\", \"absolute\");\r\n            this._graphic = document.createElement(\"canvas\");\r\n            this._container.appendChild(this._graphic);\r\n            document.onmousemove = () => this.hide();\r\n            //      Controls.addEventListener(Events.CHANGE_TRACE_VISIBILITY, () => { \r\n            //           this._enabled = !this._enabled; \r\n            //          if (this._enabled) this.will();\r\n            //       });\r\n            return this;\r\n        });\r\n        this.show = () => {\r\n            if (!this.exists()) {\r\n                this._page.appendChild(this._container);\r\n                //this.matrixEffect(this._graphic);     \r\n                this.drawTextWithAdvancedStyledParts(this._graphic);\r\n            }\r\n        };\r\n        this.hide = () => {\r\n            if (this.exists()) {\r\n                this._graphic.getContext(\"2d\").clearRect(0, 0, window.innerWidth, window.innerHeight);\r\n                this._page.removeChild(this._container);\r\n                clearInterval(this._interval);\r\n                clearTimeout(this._timeout);\r\n                this.will();\r\n            }\r\n        };\r\n        this.will = () => {\r\n            clearTimeout(this._timeout);\r\n            return (this._timeout = setTimeout(() => this.show(), 10000));\r\n        };\r\n        this.exists = () => {\r\n            return document.getElementById(\"view-page\") && document.getElementById(\"container\");\r\n        };\r\n    }\r\n    /*\r\n    \r\n        drawTextWithSimpleCycle = (canvas = this._graphic, startCol = 10, startRow = 30) => {\r\n            const text = `<div class=ds-markdown\" style=\"--ds - md - zoom: 1.143; \"><p class=\"ds - markdown - paragraph\"><span>Отличный и очень глубокий вопрос!</span></p><p class=\"ds - markdown - paragraph\"><span>Если отвечать коротко: </span><strong><span>Да, для большинства семей распределение полов в многодетных семьях вписывается в равномерное распределение и объясняется законами вероятности и случайности.</span></strong><span> Однако есть нюансы, которые создают иллюзию обратного.</span></p><p class=\"ds - markdown - paragraph\"><span>Давайте разберем подробнее.</span></p><h3><span>1. Теория вероятности и \"Закон больших чисел\"</span></h3><p class=\"ds - markdown - paragraph\"><span>Представьте, что вы подбрасываете идеальную монетку. Вероятность выпадения \"орла\" (мальчик) или \"решки\" (девочка) составляет 50%. Но если вы подбросите монетку 10 раз, вполне возможно получить, например, 7 \"орлов\" и 3 \"решки\". Это </span><strong><span>случайное отклонение</span></strong><span>.</span></p><p class=\"ds - markdown - paragraph\"><span>То же самое происходит в семьях. Рождение ребенка — это независимое событие. Пол предыдущего ребенка не влияет на пол следующего. Вероятность каждого раза составляет ~50% (на самом деле, чуть больше мальчиков рождается на свет, примерно 105 на 100 девочек, но для упрощения будем считать 50/50).</span></p><p class=\"ds - markdown - paragraph\"><span>В многодетной семье, скажем, с 5 детьми, вполне возможны комбинации:</span></p><ul><li><p class=\"ds - markdown - paragraph\"><span>5 мальчиков</span></p></li><li><p class=\"ds - markdown - paragraph\"><span>4 мальчика + 1 девочка</span></p></li><li><p class=\"ds - markdown - paragraph\"><span>3 мальчика + 2 девочки</span></p></li><li><p class=\"ds - markdown - paragraph\"><span>и т.д.</span></p></li></ul><p class=\"ds - markdown - paragraph\"><span>Чем больше детей в семье, тем больше возможных комбинаций. Комбинация \"все одного пола\" (например, 5 мальчиков) статистически маловероятна, но возможна и встречается.</span></p><p class=\"ds - markdown - paragraph\"><strong><span>Закон больших чисел</span></strong><span> гласит: чем больше испытаний (в нашем случае, рождений), тем ближе реальное соотношение будет к теоретической вероятности (50/50). Но это работает для большой совокупности (например, для всей страны статистика будет почти 50/50), а для одной конкретной семьи с ее небольшим количеством \"испытаний\" вполне нормальны значительные отклонения.</span></p><h3><span>2. Почему кажется, что это не так? (Иллюзии и исключения)</span></h3><p class=\"ds - markdown - paragraph\"><span>Есть несколько причин, по которым может создаваться впечатление, что распределение не случайно:</span></p><p class=\"ds - markdown - paragraph\"><strong><span>а) Когнитивные искажения:</span></strong></p><ul><li><p class=\"ds - markdown - paragraph\"><strong><span>Эффект выборочного внимания:</span></strong><span> Семья с 4 девочками гораздо более заметна и запоминается, чем семья с 2 мальчиками и 2 девочками. О ней чаще говорят: \"Ого, смотри, у них все девочки!\". На обычные семьи с смешанным составом не обращают внимания, и они остаются \"невидимыми\". Это искажает восприятие.</span></p></li><li><p class=\"ds - markdown - paragraph\"><strong><span>Эффект кластеризации:</span></strong><span> Наш мозг склонен искать закономерности даже в случайных данных. Последовательность Р-Р-Р-Р (девочка-девочка-девочка-девочка) кажется нам особенной, хотя ее вероятность точно такая же, как и у последовательности М-Р-М-Р.</span></p></li></ul><p class=\"ds - markdown - paragraph\"><strong><span>б) Биологические факторы (очень редко):</span></strong><span></span><br><span>В исключительных случаях может существовать </span><strong><span>генетическая предрасположенность</span></strong><span> в рамках конкретной семьи. Есть гипотезы и немногочисленные исследования, которые предполагают, что некоторые мужчины могут производить сперматозоиды с X- или Y-хромосомой в неравном соотношении. Это могло бы объяснять, почему в некоторых семьях из поколения в поколение рождаются в основном мальчики или в основном девочки. Однако это </span><strong><span>не является доказанной и распространенной нормой</span></strong><span>. Для подавляющего большинства людей соотношение X и Y сперматозоидов примерно равное.</span></p><p class=\"ds - markdown - paragraph\"><strong><span>в) Социальные факторы:</span></strong><span></span><br><span>В культурах, где важен пол ребенка (например, предпочтение сыновей), семьи, у которых продолжают рождаться девочки, будут </span><strong><span>продолжать尝试ствовать зачать ребенка</span></strong><span> до тех пор, пока не появится мальчик. В результате такие семьи становятся многодетными с бОльшим числом девочек и одним мальчиком в конце. Это не нарушение вероятности, а сознательное или социально обусловленное поведение, влияющее на итоговый состав семьи.</span></p><h3><span>Итог:</span></h3><ol start=\"1\"><li><p class=\"ds - markdown - paragraph\"><strong><span>В масштабе всего населения</span></strong><span> распределение полов близко к равномерному (с небольшим перевесом в сторону мальчиков при рождении).</span></p></li><li><p class=\"ds - markdown - paragraph\"><strong><span>В отдельно взятой многодетной семье</span></strong><span> состав детей может сильно отклоняться от идеала 50/50, и это </span><strong><span>нормальная работа случайности и вероятности</span></strong><span>. Семьи с детьми только одного пола — это статистическая редкость, но они существуют именно благодаря случайности.</span></p></li><li><p class=\"ds - markdown - paragraph\"><strong><span>Восприятие неравномерности</span></strong><span> возникает из-за того, что мы больше замечаем \"необычные\" семьи и игнорируем \"обычные\".</span></p></li></ol><p class=\"ds - markdown - paragraph\"><span>Так что, если вы видите семью с пятью мальчиками, с огромной вероятностью это просто </span><strong><span>удачная (или не очень для родителей) шутка природы и теории вероятностей</span></strong><span>, а не какой-то мистический или генетический закон.</span></p></div>`;\r\n            const context = canvas.getContext(\"2d\", { willReadFrequently: true });\r\n                            const w = (canvas.width = window.innerWidth);\r\n            const h = (canvas.height = window.innerHeight);\r\n        context.fillStyle = \"#00ff00\";\r\n        context.font = \"16px monospace\";\r\n        \r\n        const charWidth = 10;\r\n        const lineHeight = 20;\r\n        let currentCol = startCol;\r\n        let currentRow = startRow;\r\n        let index = 0;\r\n        \r\n        function getRandomChar() {\r\n            return 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'[Math.floor(Math.random() * 52)];\r\n        }\r\n        \r\n        function drawNextChar() {\r\n            if (index >= text.length) return;\r\n            \r\n            const finalChar = text[index];\r\n            const col = currentCol;\r\n            const row = currentRow;\r\n            let cycle = 0;\r\n            const maxCycles = 7;\r\n            \r\n            function cycleChar() {\r\n                if (cycle < maxCycles) {\r\n                    // Clear and draw random char\r\n                    context.clearRect(col - 1, row - 16, charWidth + 2, 21);\r\n                    context.fillText(getRandomChar(), col, row);\r\n                    cycle++;\r\n                    setTimeout(cycleChar, 250);\r\n                } else {\r\n                    // Draw final character\r\n                    context.clearRect(col - 1, row - 16, charWidth + 2, 21);\r\n                    context.fillText(finalChar, col, row);\r\n                    \r\n                    // Move to next position\r\n                    if (finalChar === '\\n') {\r\n                        currentCol = startCol;\r\n                        currentRow += lineHeight;\r\n                    } else {\r\n                        currentCol += charWidth;\r\n                        if (currentCol + charWidth > canvas.width - 10) {\r\n                            currentCol = startCol;\r\n                            currentRow += lineHeight;\r\n                        }\r\n                    }\r\n                    \r\n                    index++;\r\n                    if (index < text.length) {\r\n                        setTimeout(drawNextChar, 20);\r\n                    }\r\n                }\r\n            }\r\n            \r\n            cycleChar();\r\n        }\r\n        \r\n        context.clearRect(0, 0, canvas.width, canvas.height);\r\n        drawNextChar();\r\n    }\r\n    \r\n    private drawTextWithAdvancedWordCycle = (canvas = this._graphic, options: any = {}) => {\r\n        const {\r\n            startCol = 10,\r\n            startRow = 30,\r\n            wordTimeout = 20,\r\n            cycleCount = 3,\r\n            cycleTimeout = 10,\r\n            textColor = \"#000700ff\",\r\n            fontSize = \"16px\",\r\n            fontFamily = \"monospace\",\r\n            onComplete = null\r\n        } = options;\r\n        \r\n        const text = `За час своєї діяльності пан Віталій реалізував чимало важливих ініціатив, спрямованих на розвиток економіки міста, підтримку підприємництва та створення сприятливих умов для інвестицій.\r\n    \r\n    Компетентність, відданість справі та професійний підхід Віталія Люшина стали вагомим внеском у зміцнення та розвиток Рівненської громади.\r\n    \r\n    Тож бажаємо успіхів та нових професійних досягнень! - написали на сторінці міської ради. Нагадаємо, Віталія Люшина призначили на посаду керівника Департаменту економічного розвитку Віталія Люшина у серпні 2024 року.\r\n    \r\n    Довідково: Віталій Люшин народився 13 квітня 1977 року в селі Колодязне Березнівського району Рівненської області. Громадянин України.\r\n    \r\n    Освіта: вища, закінчив у 2001 році Рівненський державний технічний університет за спеціальністю „Землевпорядкування та кадастр”, здобувши кваліфікацію інженера-землевпорядника. У 2015 році здобув науковий ступінь кандидата економічних наук.\r\n    \r\n    З липня 2009 року по грудень 2015 року – директор Державного підприємства „Рівненський науково-дослідний та проектний інститут землеустрою”.\r\n    \r\n    З лютого 2016 року по квітень 2016 року – фізична особа-підприємець.\r\n    \r\n    З липня 2016 року по березень 2017 року працював на посаді директора технічного ТзОВ „Березне-Землемір”.\r\n    \r\n    З 27 березня 2017 року розпорядженням Президента України був призначений головою Березнівської районної державної адміністрації Рівненської області.`;\r\n            const context = canvas.getContext(\"2d\", { willReadFrequently: true });\r\n                            const w = (canvas.width = window.innerWidth);\r\n            const h = (canvas.height = window.innerHeight);\r\n        context.fillStyle = \"#000000ff\";\r\n        context.font = \"16px monospace\";\r\n        context.fillStyle = textColor;\r\n        context.font = `${fontSize} ${fontFamily}`;\r\n        \r\n        const metrics = context.measureText(\"M\");\r\n        const charWidth = metrics.width;\r\n        const lineHeight = parseInt(fontSize) * 1.2;\r\n        \r\n        let currentCol = startCol;\r\n        let currentRow = startRow;\r\n        \r\n        // Split text into words and punctuation\r\n        const wordRegex = /(\\w+|[^\\w\\s]|\\s+)/g;\r\n        const tokens = text.match(wordRegex) || [];\r\n        let tokenIndex = 0;\r\n        \r\n        function getRandomChar() {\r\n            const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n            return chars[Math.floor(Math.random() * chars.length)];\r\n        }\r\n        \r\n        //@ts-ignore\r\n        function drawCharAtPosition(char, col, row) {\r\n            context.clearRect(col - 1, row - parseInt(fontSize), charWidth + 2, parseInt(fontSize) + 5);\r\n            context.fillText(char, col, row);\r\n        }\r\n        \r\n        function processToken() {\r\n            if (tokenIndex >= tokens.length) {\r\n                if (onComplete) onComplete();\r\n                return;\r\n            }\r\n            \r\n            const token = tokens[tokenIndex];\r\n            const isWhitespace = /^\\s+$/.test(token);\r\n            \r\n            if (isWhitespace) {\r\n                // Just draw whitespace immediately without cycling\r\n                for (let i = 0; i < token.length; i++) {\r\n                    if (token[i] === ' ') {\r\n                        currentCol += charWidth;\r\n                    } else if (token[i] === '\\n') {\r\n                        currentCol = startCol;\r\n                        currentRow += lineHeight;\r\n                    }\r\n                    \r\n                    // Handle line wrapping\r\n                    if (currentCol + charWidth > canvas.width - 10) {\r\n                        currentCol = startCol;\r\n                        currentRow += lineHeight;\r\n                    }\r\n                }\r\n                \r\n                tokenIndex++;\r\n                setTimeout(processToken, 50);\r\n                return;\r\n            }\r\n            \r\n            // Process word or punctuation with cycling effect\r\n                //@ts-ignore\r\n            const charPositions = [];\r\n            let tempCol = currentCol;\r\n            \r\n            for (let i = 0; i < token.length; i++) {\r\n                charPositions.push({ col: tempCol, row: currentRow });\r\n                tempCol += charWidth;\r\n                \r\n                if (tempCol + charWidth > canvas.width - 10) {\r\n                    tempCol = startCol;\r\n                    currentRow += lineHeight;\r\n                }\r\n            }\r\n            \r\n            let charIndex = 0;\r\n            let cycleIndex = 0;\r\n            \r\n            function cycleToken() {\r\n                if (cycleIndex < cycleCount) {\r\n                    // Draw random characters for the entire token\r\n                    for (let i = 0; i < token.length; i++) {\r\n                            //@ts-ignore\r\n                        drawCharAtPosition(getRandomChar(), charPositions[i].col, charPositions[i].row);\r\n                    }\r\n                    cycleIndex++;\r\n                    setTimeout(cycleToken, cycleTimeout);\r\n                } else {\r\n                    // Finalize current character\r\n                    if (charIndex < token.length) {\r\n                            //@ts-ignore\r\n                        drawCharAtPosition(token[charIndex], charPositions[charIndex].col, charPositions[charIndex].row);\r\n                        charIndex++;\r\n                        setTimeout(cycleToken, cycleTimeout / 2);\r\n                    } else {\r\n                        // Token completed, move to next\r\n                            //@ts-ignore\r\n                        currentCol = charPositions[charPositions.length - 1].col + charWidth;\r\n                        tokenIndex++;\r\n                        \r\n                        if (tokenIndex < tokens.length) {\r\n                            setTimeout(processToken, wordTimeout);\r\n                        } else {\r\n                            if (onComplete) onComplete();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \r\n            cycleToken();\r\n        }\r\n        \r\n        context.clearRect(0, 0, canvas.width, canvas.height);\r\n        processToken();\r\n    }\r\n    \r\n    private drawTextWithLineCycle = (canvas = this._graphic, options: any = {}) => {\r\n        const {\r\n            startCol = 10,\r\n            startRow = 30,\r\n            lineTimeout = 20,\r\n            cycleCount = 10,\r\n            cycleTimeout = 20,\r\n            textColor = \"#00ff00\",\r\n            fontSize = \"16px\",\r\n            fontFamily = \"monospace\",\r\n            onComplete = null\r\n        } = options;\r\n        \r\n        const text = `За час своєї діяльності пан Віталій реалізував чимало важливих ініціатив, спрямованих на розвиток економіки міста, підтримку підприємництва та створення сприятливих умов для інвестицій.\r\n    \r\n    Компетентність, відданість справі та професійний підхід Віталія Люшина стали вагомим внеском у зміцнення та розвиток Рівненської громади.\r\n    \r\n    Тож бажаємо успіхів та нових професійних досягнень! - написали на сторінці міської ради. Нагадаємо, Віталія Люшина призначили на посаду керівника Департаменту економічного розвитку Віталія Люшина у серпні 2024 року.\r\n    \r\n    Довідково: Віталій Люшин народився 13 квітня 1977 року в селі Колодязне Березнівського району Рівненської області. Громадянин України.\r\n    \r\n    Освіта: вища, закінчив у 2001 році Рівненський державний технічний університет за спеціальністю „Землевпорядкування та кадастр”, здобувши кваліфікацію інженера-землевпорядника. У 2015 році здобув науковий ступінь кандидата економічних наук.\r\n    \r\n    З липня 2009 року по грудень 2015 року – директор Державного підприємства „Рівненський науково-дослідний та проектний інститут землеустрою”.\r\n    \r\n    З лютого 2016 року по квітень 2016 року – фізична особа-підприємець.\r\n    \r\n    З липня 2016 року по березень 2017 року працював на посаді директора технічного ТзОВ „Березне-Землемір”.\r\n    \r\n    З 27 березня 2017 року розпорядженням Президента України був призначений головою Березнівської районної державної адміністрації Рівненської області.`;\r\n            const context = canvas.getContext(\"2d\", { willReadFrequently: true });\r\n                            const w = (canvas.width = window.innerWidth);\r\n            const h = (canvas.height = window.innerHeight);\r\n        context.fillStyle = \"#000000ff\";\r\n        context.font = \"16px monospace\";\r\n        \r\n        // Measure text for accurate positioning\r\n        const metrics = context.measureText(\"M\");\r\n        const charWidth = metrics.width;\r\n        const lineHeight = parseInt(fontSize) * 1.2;\r\n        \r\n        let currentCol = startCol;\r\n        let currentRow = startRow;\r\n        let lineIndex = 0;\r\n        \r\n        // Split text into lines\r\n        const lines = text.split('\\n');\r\n        \r\n        // Function to generate random character (a-z, A-Z)\r\n        function getRandomChar() {\r\n            const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n            return chars[Math.floor(Math.random() * chars.length)];\r\n        }\r\n        \r\n        //@ts-ignore\r\n        function drawCharAtPosition(char, col, row) {\r\n            // Clear previous character area\r\n            context.clearRect(col - 1, row - parseInt(fontSize), charWidth + 2, parseInt(fontSize) + 5);\r\n            context.fillText(char, col, row);\r\n        }\r\n        \r\n            //@ts-ignore\r\n        function processLine(line) {\r\n            if (lineIndex >= lines.length) {\r\n                if (onComplete) onComplete();\r\n                return;\r\n            }\r\n            \r\n            const currentLine = lines[lineIndex];\r\n            let charIndex = 0;\r\n                //@ts-ignore\r\n            const charPositions = [];\r\n            \r\n            // Calculate all character positions first\r\n            let tempCol = currentCol;\r\n            for (let i = 0; i < currentLine.length; i++) {\r\n                charPositions.push({ col: tempCol, row: currentRow });\r\n                tempCol += charWidth;\r\n                \r\n                // Handle line wrapping within the line\r\n                if (tempCol + charWidth > canvas.width - 10) {\r\n                    tempCol = startCol;\r\n                    currentRow += lineHeight;\r\n                }\r\n            }\r\n            \r\n            function processCharacter() {\r\n                if (charIndex >= currentLine.length) {\r\n                    // Move to next line after all characters in current line are done\r\n                    currentCol = startCol;\r\n                    currentRow += lineHeight;\r\n                    lineIndex++;\r\n                    \r\n                    if (lineIndex < lines.length) {\r\n                        setTimeout(() => processLine(lines[lineIndex]), lineTimeout);\r\n                    } else {\r\n                        if (onComplete) onComplete();\r\n                    }\r\n                    return;\r\n                }\r\n                \r\n                const finalChar = currentLine[charIndex];\r\n                    //@ts-ignore\r\n                const position = charPositions[charIndex];\r\n                let cycleIndex = 0;\r\n                \r\n                function cycleRandomChars() {\r\n                    if (cycleIndex < cycleCount) {\r\n                        // Draw random character for all subsequent characters that haven't been finalized yet\r\n                        for (let i = charIndex; i < currentLine.length; i++) {\r\n                            const randomChar = getRandomChar();\r\n                                //@ts-ignore\r\n                            drawCharAtPosition(randomChar, charPositions[i].col, charPositions[i].row);\r\n                        }\r\n                        \r\n                        cycleIndex++;\r\n                        setTimeout(cycleRandomChars, cycleTimeout);\r\n                    } else {\r\n                        // Draw final character for this position\r\n                        drawCharAtPosition(finalChar, position.col, position.row);\r\n                        \r\n                        // For all previous characters, make sure they stay as their final characters\r\n                        for (let i = 0; i < charIndex; i++) {\r\n                                //@ts-ignore\r\n                            drawCharAtPosition(currentLine[i], charPositions[i].col, charPositions[i].row);\r\n                        }\r\n                        \r\n                        charIndex++;\r\n                        processCharacter();\r\n                    }\r\n                }\r\n                \r\n                // Start the cycling effect for this character and all following ones in the line\r\n                cycleRandomChars();\r\n            }\r\n            \r\n            // Start processing the first character of the line\r\n            processCharacter();\r\n        }\r\n        \r\n        // Clear canvas and start\r\n        context.clearRect(0, 0, canvas.width, canvas.height);\r\n        processLine(lines[0]);\r\n    }\r\n    \r\n    \r\n    private drawTextWithSimpleLineCycle(canvas = this._graphic, startCol = 10, startRow = 30) {\r\n      const text = `За час своєї діяльності пан Віталій реалізував чимало важливих ініціатив, спрямованих на розвиток економіки міста,\\n` +\r\n                        `підтримку підприємництва та створення сприятливих умов для інвестицій.\\n` +\r\n                        `Компетентність, відданість справі та професійний підхід Віталія Люшина стали вагомим внеском у зміцнення та розвиток Рівненської громади.\\n` +\r\n                        `Тож бажаємо успіхів та нових професійних досягнень! - написали на сторінці міської ради. Нагадаємо, Віталія Люшина призначили'\\n'` +\r\n                        `на посаду керівника Департаменту економічного розвитку Віталія Люшина у серпні 2024 року.\\n` +\r\n                        `Довідково: Віталій Люшин народився 13 квітня 1977 року в селі Колодязне Березнівського району Рівненської області. Громадянин України.\\n` +\r\n                        `Освіта: вища, закінчив у 2001 році Рівненський державний технічний університет за спеціальністю „Землевпорядкування та кадастр”,\\n` +\r\n                        `здобувши кваліфікацію інженера-землевпорядника. У 2015 році здобув науковий ступінь кандидата економічних наук.\\n` +\r\n                        `З липня 2009 року по грудень 2015 року – директор Державного підприємства „Рівненський науково-дослідний та проектний' інститут землеустрою”.\\n` +\r\n                        `З лютого 2016 року по квітень 2016 року – фізична особа-підприємець.\\n` +\r\n                        `З липня 2016 року по березень 2017 року працював на посаді директора технічного ТзОВ „Березне-Землемір”.\\n` +\r\n                        `З 27 березня 2017 року розпорядженням Президента України був призначений головою Березнівської районної державної адміністрації Рівненської області.`;\r\n            const context = canvas.getContext(\"2d\", { willReadFrequently: true });\r\n                            const w = (canvas.width = window.innerWidth);\r\n            const h = (canvas.height = window.innerHeight);\r\n        context.fillStyle = \"#000000ff\";\r\n        context.font = \"16px monospace\";\r\n        \r\n        const charWidth = 10;\r\n        const lineHeight = 20;\r\n        const lines = text.split('\\n');\r\n        let lineIndex = 0;\r\n        let currentRow = startRow;\r\n        \r\n        function getRandomChar() {\r\n            return 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'[Math.floor(Math.random() * 52)];\r\n        }\r\n        \r\n        function processLine() {\r\n            if (lineIndex >= lines.length) return;\r\n            \r\n            const line = lines[lineIndex];\r\n            let cycle = 0;\r\n            const maxCycles = 10;\r\n            //@ts-ignore\r\n            const charPositions = [];\r\n            \r\n            // Calculate character positions\r\n            let currentCol = startCol;\r\n            for (let i = 0; i < line.length; i++) {\r\n                charPositions.push(currentCol);\r\n                currentCol += charWidth;\r\n            }\r\n            \r\n            function cycleLine() {\r\n                if (cycle < maxCycles) {\r\n                    // Clear the line area\r\n                    context.clearRect(startCol - 5, currentRow - 18, canvas.width - startCol, 22);\r\n                    \r\n                    // Draw random characters for entire line\r\n                    for (let i = 0; i < line.length; i++) {\r\n                                //@ts-ignore\r\n                        context.fillText(getRandomChar(), charPositions[i], currentRow);\r\n                    }\r\n                    \r\n                    cycle++;\r\n                    setTimeout(cycleLine, 20);\r\n                } else {\r\n                    // Draw final line\r\n                    context.clearRect(startCol - 5, currentRow - 18, canvas.width - startCol, 22);\r\n                    for (let i = 0; i < line.length; i++) {\r\n                                //@ts-ignore\r\n                        context.fillText(line[i], charPositions[i], currentRow);\r\n                    }\r\n                    \r\n                    // Move to next line\r\n                    currentRow += lineHeight;\r\n                    lineIndex++;\r\n                    \r\n                    if (lineIndex < lines.length) {\r\n                        setTimeout(processLine, 120);\r\n                    }\r\n                }\r\n            }\r\n            \r\n            cycleLine();\r\n        }\r\n        \r\n        context.clearRect(0, 0, canvas.width, canvas.height);\r\n        processLine();\r\n    }\r\n    */\r\n    matrixEffect(canvas, font = 24) {\r\n        const context = canvas.getContext(\"2d\", { willReadFrequently: true });\r\n        const w = (canvas.width = window.innerWidth);\r\n        const h = (canvas.height = window.innerHeight);\r\n        const str = \"А+Б0ƓВڲ-Г1Д=Е2Ё Ж3З И4Йۺ К5Лإ М6Нڧ О7П ۴ڟ Ф!ڮХ ЦÛ?Ч ƪШ.іагb н ьцск бйщцгу ритй\" +\r\n            \"шлщшб пр,Ы Ь:ЭЮ;ڿڿڦЯ 开儿 艾  诶Ƣ 开伊 艾2 艾ƕڪ   西Ý 吉 3艾 %$艾 伊4 ¿ 67 娜% ڠ伊\" +\r\n            \"6a bcƜ dٿefïo#pؠ-qrstu &v* ڜ wxy3z ¼ ¾ æè ƩỺ ʭʩʥ˩˩ͼ  ͽͽΔΔΔΔω ϘϠ ϠϡϢϧ Ϩ ϬϬϪЉЊ\" +\r\n            \"1871640532 1 udp 1677729535 188.212777 typ srflx raddr 0.0.0.0 rport 0 generation 0\" +\r\n            \"ufrag AfOL network-coe:832498458 1 udp 1677729535 4147.105 55549 typ srflx\" +\r\n            \" raddr 0.0.0.0 rport 0 generation 0 ufrag 4W3O ne ϲτ χ κ ͷρ φ \tπ314 ʏ ƙ ɜ ӆ ϰ ƴ\" +\r\n            \"и̷ ய ౦ ӥ ❡ ㄐ и̷ௐ ჯ ய౦? ቀ \tჶ ෲ? ƿ ᗱ ㄏ ㄨ ȹ Ⴏ ȝ Κ Ͷ Λ  Ο Φ Η БΛЯΤЬ ❞૱ઐᙓዘҚ☯\" +\r\n            \" нaχƴй ㄨㄦ੦ഠ〇ㄇㄐ૯ㄏㄏ πiȝgyютьㄇㄈ ㄋ ㄏ ㄐ ㄒ\tㄗ ㄙ ㄚ\t ㄤ ㄥ ㄦ ㄨ ㄩ\t4TG\";\r\n        const matrix = str.split(\"\");\r\n        let cols = w / font;\r\n        let pool = [];\r\n        for (let i = 0; i < cols; i++)\r\n            pool[i] = 1;\r\n        const draw = () => {\r\n            context.fillStyle = \"rgba(0,0,0,.05)\";\r\n            context.fillRect(0, 0, w, h);\r\n            context.fillStyle = \"#00ff00\";\r\n            //     if (Math.random() > 0.9955) {\r\n            //         context.fillStyle = \"#f00\";\r\n            //      }\r\n            context.font = font + \"px system-ui\";\r\n            for (let i = 0; i < pool.length; i++) {\r\n                const txt = matrix[Math.floor(Math.random() * matrix.length)];\r\n                context.fillText(txt, i * font, pool[i] * font);\r\n                if (pool[i] * font > h /* && Math.random() > 0.95*/)\r\n                    pool[i] = 0;\r\n                pool[i]++;\r\n            }\r\n        };\r\n        this._interval = setInterval(draw, 77);\r\n    }\r\n    /*private drawTextWithSimpleTimedLineCycle = (canvas = this._graphic,  options: any = {}) => {\r\n\r\n\r\n        const text = `За час своєї діяльності пан Віталій реалізував чимало важливих ініціатив, спрямованих на розвиток економіки міста,'\\n'` +\r\n                    `підтримку підприємництва та створення сприятливих умов для інвестицій.'\\n'` +\r\n                    `Компетентність, відданість справі та професійний підхід Віталія Люшина стали вагомим внеском у зміцнення та розвиток Рівненської громади.'\\n'` +\r\n                    `Тож бажаємо успіхів та нових професійних досягнень! - написали на сторінці міської ради. Нагадаємо, Віталія Люшина призначили'\\n'` +\r\n                    `на посаду керівника Департаменту економічного розвитку Віталія Люшина у серпні 2024 року.'\\n'` +\r\n                    `Довідково: Віталій Люшин народився 13 квітня 1977 року в селі Колодязне Березнівського району Рівненської області. Громадянин України.'\\n'` +\r\n                    `Освіта: вища, закінчив у 2001 році Рівненський державний технічний університет за спеціальністю „Землевпорядкування та кадастр”,'\\n'` +\r\n                    `здобувши кваліфікацію інженера-землевпорядника. У 2015 році здобув науковий ступінь кандидата економічних наук.'\\n'` +\r\n                    `З липня 2009 року по грудень 2015 року – директор Державного підприємства „Рівненський науково-дослідний та проектний' інститут землеустрою”.'\\n'` +\r\n                    `З лютого 2016 року по квітень 2016 року – фізична особа-підприємець.'\\n'` +\r\n                    `З липня 2016 року по березень 2017 року працював на посаді директора технічного ТзОВ „Березне-Землемір”.'\\n'` +\r\n                    `З 27 березня 2017 року розпорядженням Президента України був призначений головою Березнівської районної державної адміністрації Рівненської області.'\\n'`;\r\n\r\n    \r\n        // Set canvas to full window size\r\n    canvas.width = window.innerWidth;\r\n    canvas.height = window.innerHeight;\r\n    \r\n    const {\r\n        startCol = 10, // Increased default for better margins\r\n        startRow = 30, // Increased default for better margins\r\n        effectCompletionTime = 1000,\r\n        cycleCount = 10,\r\n        cycleTimeout = 20,\r\n        textColor = \"#000000ff\",\r\n        fontSize = \"18px\", // Slightly larger for better readability on full screen\r\n        fontFamily = \"monospace\",\r\n        margin = 20, // Margin from edges\r\n        onComplete = null,\r\n        onLineStart = null,\r\n        onLineEnd = null\r\n    } = options;\r\n    \r\n    const context = canvas.getContext(\"2d\", { willReadFrequently: true });\r\n\r\n        context.fillStyle = \"#000000ff\";\r\n    context.font = \"16px monospace\";\r\n    // Measure text for accurate positioning\r\n    const metrics = context.measureText(\"M\");\r\n    const charWidth = metrics.width;\r\n    const lineHeight = parseInt(fontSize) * 1.2; // Increased line height for full screen\r\n    \r\n    let currentCol = startCol;\r\n    let currentRow = startRow;\r\n    let lineIndex = 0;\r\n    const lines = text.split('\\n').filter(line => line.trim().length > 0);\r\n    \r\n    // Calculate available width for text wrapping\r\n    const maxWidth = canvas.width - margin * 2;\r\n    \r\n    // Calculate time per line based on total completion time\r\n    const lineTimeout = Math.max(500, Math.floor(effectCompletionTime / Math.max(1, lines.length)));\r\n    const interLineDelay = Math.min(200, Math.floor(lineTimeout * 0.15));\r\n    \r\n    function getRandomChar() {\r\n        const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n        return chars[Math.floor(Math.random() * chars.length)];\r\n    }\r\n    \r\n    //@ts-ignore\r\n    function drawCharAtPosition(char, col, row) {\r\n        // Clear a slightly larger area to prevent artifacts\r\n        context.clearRect(col - 2, row - parseInt(fontSize) - 2, charWidth + 4, parseInt(fontSize) + 8);\r\n        context.fillText(char, col, row);\r\n    }\r\n    \r\n    function processLine() {\r\n        if (lineIndex >= lines.length) {\r\n            if (onComplete) onComplete();\r\n            return;\r\n        }\r\n        \r\n        const line = lines[lineIndex];\r\n        if (onLineStart) onLineStart(lineIndex, line, lineTimeout);\r\n        \r\n            //@ts-ignore\r\n        const charPositions = [];\r\n        let tempCol = currentCol;\r\n        let tempRow = currentRow;\r\n        \r\n        // Handle text wrapping for each character in the line\r\n        for (let i = 0; i < line.length; i++) {\r\n            const char = line[i];\r\n            \r\n            // Handle newlines within lines\r\n            if (char === '\\n') {\r\n                tempCol = startCol;\r\n                tempRow += lineHeight;\r\n                continue;\r\n            }\r\n            \r\n            // Check if we need to wrap to next line\r\n            if (tempCol + charWidth > maxWidth) {\r\n                tempCol = startCol;\r\n                tempRow += lineHeight;\r\n            }\r\n            \r\n            charPositions.push({ col: tempCol, row: tempRow, char: char });\r\n            tempCol += charWidth;\r\n        }\r\n        \r\n            //@ts-ignore\r\n        let cycleInterval;\r\n        let currentCycle = 0;\r\n        const maxCycles = Math.max(5, Math.min(cycleCount, Math.floor(lineTimeout / cycleTimeout)));\r\n        \r\n        function cycleLine() {\r\n            if (currentCycle < maxCycles) {\r\n                // Draw random characters for all positions\r\n                for (let i = 0; i < charPositions.length; i++) {\r\n                        //@ts-ignore\r\n                    drawCharAtPosition(getRandomChar(), charPositions[i].col, charPositions[i].row);\r\n                }\r\n                currentCycle++;\r\n            } else {\r\n                // Stop cycling and show final text\r\n                    //@ts-ignore\r\n                clearInterval(cycleInterval);\r\n                for (let i = 0; i < charPositions.length; i++) {\r\n                        //@ts-ignore\r\n                    drawCharAtPosition(charPositions[i].char, charPositions[i].col, charPositions[i].row);\r\n                }\r\n            }\r\n        }\r\n        \r\n        function finalizeAndMove() {\r\n                //@ts-ignore\r\n            clearInterval(cycleInterval);\r\n            \r\n            // Ensure final text is drawn\r\n            for (let i = 0; i < charPositions.length; i++) {\r\n                    //@ts-ignore\r\n                drawCharAtPosition(charPositions[i].char, charPositions[i].col, charPositions[i].row);\r\n            }\r\n            \r\n            if (onLineEnd) onLineEnd(lineIndex, line);\r\n            \r\n            // Update position for next line\r\n            currentCol = startCol;\r\n            currentRow = tempRow + lineHeight; // Move to next line position\r\n            \r\n            // Check if we're going off screen\r\n            if (currentRow > canvas.height - margin) {\r\n                // Reset to top if we reach bottom (optional: could pause or stop)\r\n                currentRow = startRow;\r\n            }\r\n            \r\n            lineIndex++;\r\n            \r\n            if (lineIndex < lines.length) {\r\n                setTimeout(processLine, interLineDelay);\r\n            } else {\r\n                if (onComplete) onComplete();\r\n            }\r\n        }\r\n        \r\n        // Start the cycling effect\r\n        cycleInterval = setInterval(cycleLine, cycleTimeout);\r\n        \r\n        // Set timeout to move to next line\r\n        setTimeout(finalizeAndMove, lineTimeout);\r\n    }\r\n    \r\n    // Clear canvas with a dark background for better contrast\r\n    context.fillStyle = \"#ffffffff\";\r\n    context.fillRect(0, 0, canvas.width, canvas.height);\r\n    context.fillStyle = textColor;\r\n    \r\n    // Handle window resize\r\n    function handleResize() {\r\n        canvas.width = window.innerWidth;\r\n        canvas.height = window.innerHeight;\r\n        context.fillStyle = \"#ffffffff\";\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        context.fillStyle = textColor;\r\n        context.font = `${fontSize} ${fontFamily}`;\r\n    }\r\n    \r\n    window.addEventListener('resize', handleResize);\r\n    \r\n    // Cleanup function\r\n    const cleanup = () => {\r\n        window.removeEventListener('resize', handleResize);\r\n    };\r\n    \r\n    if (lines.length > 0) {\r\n        processLine();\r\n    } else if (onComplete) {\r\n        onComplete();\r\n    }\r\n    \r\n    return cleanup; // Return cleanup function\r\n}\r\n\r\nprivate drawTextWithOverlappingLineCycle = (canvas = this._graphic, options: any = {}) => {\r\n    const {\r\n        startCol = 10,\r\n        startRow = 30,\r\n        lineTimeout = 2000,\r\n        cycleCount = 10,\r\n        cycleTimeout = 20,\r\n        lineStartDelay = 100, // Delay before starting next line\r\n        textColor = \"#00ff00\",\r\n        fontSize = \"16px\",\r\n        fontFamily = \"monospace\",\r\n        onComplete = null\r\n    } = options;\r\n    \r\n    const context = canvas.getContext(\"2d\", { willReadFrequently: true });\r\n                        const w = (canvas.width = window.innerWidth);\r\n        const h = (canvas.height = window.innerHeight);\r\n    context.fillStyle = \"#000000ff\";\r\n    context.font = \"16px monospace\";\r\n    \r\n    const charWidth = 10;\r\n    const lineHeight = 20;\r\n    const lines = this.text.split('\\n');\r\n    let lineIndex = 0;\r\n    let currentRow = startRow;\r\n    \r\n    // Store all line intervals for cleanup\r\n    //@ts-ignore\r\n    const lineIntervals = [];\r\n        //@ts-ignore\r\n    const lineTimeouts = [];\r\n    \r\n    function getRandomChar() {\r\n        return 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'[Math.floor(Math.random() * 52)];\r\n    }\r\n        //@ts-ignore\r\n    function processLine(lineIndex) {\r\n        if (lineIndex >= lines.length) {\r\n            // Check if all lines are done\r\n            if (lineIndex === lines.length && onComplete) {\r\n                setTimeout(onComplete, lineTimeout);\r\n            }\r\n            return;\r\n        }\r\n        \r\n        const line = lines[lineIndex];\r\n        let cycle = 0;\r\n        const maxCycles = cycleCount;\r\n            //@ts-ignore\r\n        const charPositions = [];\r\n        \r\n        // Calculate character positions for this line\r\n        let currentCol = startCol;\r\n        for (let i = 0; i < line.length; i++) {\r\n            charPositions.push(currentCol);\r\n            currentCol += charWidth;\r\n        }\r\n        \r\n        function drawRandomLine() {\r\n            // Clear only this line's area\r\n            context.clearRect(startCol - 5, currentRow - 18, canvas.width - startCol, 22);\r\n            \r\n            // Draw random characters for entire line\r\n            for (let i = 0; i < line.length; i++) {\r\n                    //@ts-ignore\r\n                context.fillText(getRandomChar(), charPositions[i], currentRow);\r\n            }\r\n        }\r\n        \r\n        function drawFinalLine() {\r\n            // Draw final text for this line\r\n            for (let i = 0; i < line.length; i++) {\r\n                    //@ts-ignore\r\n                context.fillText(line[i], charPositions[i], currentRow);\r\n            }\r\n        }\r\n        \r\n        function cycleCurrentLine() {\r\n            if (cycle < maxCycles) {\r\n                drawRandomLine();\r\n                cycle++;\r\n            } else {\r\n                // Stop cycling and show final text\r\n                drawFinalLine();\r\n                clearInterval(intervalId);\r\n                \r\n                // Remove from intervals array\r\n                    //@ts-ignore\r\n                const index = lineIntervals.indexOf(intervalId);\r\n                if (index > -1) {\r\n                        //@ts-ignore\r\n                    lineIntervals.splice(index, 1);\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Start cycling for this line\r\n        const intervalId = setInterval(cycleCurrentLine, cycleTimeout);\r\n        lineIntervals.push(intervalId);\r\n        \r\n        // Set timeout to stop cycling and show final text for this line\r\n        const timeoutId = setTimeout(() => {\r\n            clearInterval(intervalId);\r\n            drawFinalLine();\r\n            \r\n            // Remove from arrays\r\n                //@ts-ignore\r\n            const intervalIndex = lineIntervals.indexOf(intervalId);\r\n            if (intervalIndex > -1) {\r\n                    //@ts-ignore\r\n                lineIntervals.splice(intervalIndex, 1);\r\n            }\r\n                //@ts-ignore\r\n            const timeoutIndex = lineTimeouts.indexOf(timeoutId);\r\n            if (timeoutIndex > -1) {\r\n                    //@ts-ignore\r\n                lineTimeouts.splice(timeoutIndex, 1);\r\n            }\r\n        }, lineTimeout);\r\n        \r\n        lineTimeouts.push(timeoutId);\r\n        \r\n        // Move to next line position\r\n        currentRow += lineHeight;\r\n        \r\n        // Start next line after delay (if there are more lines)\r\n        if (lineIndex + 1 < lines.length) {\r\n            setTimeout(() => processLine(lineIndex + 1), lineStartDelay);\r\n        }\r\n    }\r\n    \r\n    // Clear canvas and start first line\r\n    context.clearRect(0, 0, canvas.width, canvas.height);\r\n    processLine(0);\r\n    \r\n    // Return cleanup function\r\n    return () => {\r\n            //@ts-ignore\r\n        lineIntervals.forEach(clearInterval);\r\n            //@ts-ignore\r\n        lineTimeouts.forEach(clearTimeout);\r\n    };\r\n}*/\r\n    drawTextWithAdvancedStyledParts(canvas = this._graphic, textParts = this.text, options = {}) {\r\n        const { startCol = 20, startRow = 50, lineDuration = 2500, cycleSpeed = 25, lineSpacing = 120, defaultTextColor = \"#000000ff\", defaultFont = \"18px monospace\", backgroundColor = \"#000000\", onComplete = null, onPartStart = null, onPartEnd = null } = options;\r\n        // const context = canvas.getContext(\"2d\", { willReadFrequently: true });\r\n        const context = canvas.getContext(\"2d\", { willReadFrequently: true });\r\n        const w = (canvas.width = window.innerWidth);\r\n        const h = (canvas.height = window.innerHeight);\r\n        context.fillStyle = \"#000000ff\";\r\n        context.font = \"bold 16px monospace\";\r\n        // Set background\r\n        //  context.fillStyle = backgroundColor;\r\n        //  context.fillRect(0, 0, canvas.width, canvas.height);\r\n        // Process text parts with individual styles\r\n        //@ts-ignore\r\n        const animatedLines = [];\r\n        let currentY = startRow;\r\n        //@ts-ignore\r\n        textParts.forEach((textPart, partIndex) => {\r\n            const { part: text, font = defaultFont, color = defaultTextColor, align = \"left\", \r\n            //@ts-ignore\r\n            spacing = 0 } = textPart;\r\n            const lines = text.split('\\n');\r\n            const fontSize = parseInt(font);\r\n            //@ts-ignore\r\n            lines.forEach((line, lineIndex) => {\r\n                if (line.trim().length > 0) {\r\n                    animatedLines.push({\r\n                        text: line,\r\n                        font,\r\n                        color,\r\n                        align,\r\n                        y: currentY,\r\n                        partIndex,\r\n                        lineIndex\r\n                    });\r\n                }\r\n                currentY += fontSize * 1.5 + spacing;\r\n            });\r\n            // Add extra spacing after each part\r\n            currentY += 10;\r\n        });\r\n        const activeAnimations = new Map();\r\n        let completedCount = 0;\r\n        function getRandomChar() {\r\n            //@ts-ignore\r\n            return 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'[Math.floor(Math.random() * 30)];\r\n        }\r\n        //@ts-ignore\r\n        function startLineAnimation(lineData, index) {\r\n            const { text, font, color, align, y, partIndex } = lineData;\r\n            const startTime = Date.now();\r\n            context.font = 'bold ' + font;\r\n            context.fillStyle = color;\r\n            const charWidth = context.measureText(\"M\").width;\r\n            const fontSize = parseInt(font);\r\n            // Calculate starting position based on alignment\r\n            let startX;\r\n            const textWidth = text.length * charWidth;\r\n            switch (align) {\r\n                case \"center\":\r\n                    startX = (canvas.width - textWidth) / 2;\r\n                    break;\r\n                case \"right\":\r\n                    startX = canvas.width - textWidth - startCol;\r\n                    break;\r\n                default: // left\r\n                    startX = startCol;\r\n            }\r\n            //@ts-ignore\r\n            const charPositions = [];\r\n            let currentX = startX;\r\n            for (let i = 0; i < text.length; i++) {\r\n                charPositions.push(currentX);\r\n                currentX += charWidth;\r\n            }\r\n            function animate() {\r\n                const elapsed = Date.now() - startTime;\r\n                const progress = Math.min(1, elapsed / lineDuration);\r\n                // Clear line area\r\n                context.clearRect(0, y - fontSize - 5, canvas.width, fontSize + 10);\r\n                if (progress < 1) {\r\n                    // Animation in progress - mix random and final chars\r\n                    for (let i = 0; i < text.length; i++) {\r\n                        if (Math.random() > progress * 0.6) {\r\n                            //@ts-ignore\r\n                            context.fillText(getRandomChar(), charPositions[i], y);\r\n                        }\r\n                        else {\r\n                            //@ts-ignore\r\n                            context.fillText(text[i], charPositions[i], y);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // Animation complete\r\n                    clearInterval(intervalId);\r\n                    activeAnimations.delete(index);\r\n                    // Draw final text\r\n                    for (let i = 0; i < text.length; i++) {\r\n                        //@ts-ignore\r\n                        context.fillText(text[i], charPositions[i], y);\r\n                    }\r\n                    completedCount++;\r\n                    if (onPartEnd)\r\n                        onPartEnd(partIndex, text, font, color);\r\n                    if (completedCount === animatedLines.length && onComplete) {\r\n                        onComplete();\r\n                    }\r\n                }\r\n            }\r\n            if (onPartStart)\r\n                onPartStart(partIndex, text, font, color);\r\n            const intervalId = setInterval(animate, cycleSpeed);\r\n            activeAnimations.set(index, { intervalId, startTime, y });\r\n        }\r\n        // Start all line animations\r\n        //@ts-ignore\r\n        animatedLines.forEach((lineData, index) => {\r\n            setTimeout(() => {\r\n                startLineAnimation(lineData, index);\r\n            }, index * lineSpacing);\r\n        });\r\n        return () => {\r\n            activeAnimations.forEach((animation, index) => {\r\n                clearInterval(animation.intervalId);\r\n                // Draw final state\r\n                //@ts-ignore\r\n                const lineData = animatedLines[index];\r\n                context.font = lineData.font;\r\n                context.fillStyle = lineData.color;\r\n                const charWidth = context.measureText(\"M\").width;\r\n                let startX;\r\n                const textWidth = lineData.text.length * charWidth;\r\n                switch (lineData.align) {\r\n                    case \"center\":\r\n                        startX = (canvas.width - textWidth) / 2;\r\n                        break;\r\n                    case \"right\":\r\n                        startX = canvas.width - textWidth - startCol;\r\n                        break;\r\n                    default:\r\n                        startX = startCol;\r\n                }\r\n                context.clearRect(0, lineData.y - parseInt(lineData.font) - 5, canvas.width, parseInt(lineData.font) + 10);\r\n                for (let i = 0; i < lineData.text.length; i++) {\r\n                    context.fillText(lineData.text[i], startX + i * charWidth, lineData.y);\r\n                }\r\n            });\r\n            activeAnimations.clear();\r\n        };\r\n    }\r\n}\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Matrix());\r\n\n\n//# sourceURL=webpack://html-static-myself/./src/Matrix.ts?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/Entry.ts");
/******/ 	
/******/ })()
;